document.addEventListener('DOMContentLoaded', () => {
    const providerSelect = document.getElementById('provider');
    const modelSelect = document.getElementById('model');
    const apiKeyGroup = document.getElementById('apiKeyGroup');
    const apiKeyInput = document.getElementById('apiKey');
    const directoryInput = document.getElementById('directory');
    const baseUrlInput = document.getElementById('baseUrl');
    const framesInput = document.getElementById('frames');
    const caseStyleInput = document.getElementById('caseStyle');
    const charsInput = document.getElementById('chars');
    const languageInput = document.getElementById('language');
    const includeSubdirectoriesInput = document.getElementById('includeSubdirectories');
    const customPromptInput = document.getElementById('customPrompt');
    const errorSummary = document.getElementById('errorSummary');
    const providerInfo = document.getElementById('providerInfo');
    const commandForm = document.getElementById('commandForm');
    const testCommandBtn = document.getElementById('testCommandBtn');
  
    // 1. Load preferences from localStorage
    loadPreferences();
  
    // 2. Update the model list & provider toggles
    updateModels();
  
    // 3. Add event listeners
    providerSelect.addEventListener('change', updateModels);
    commandForm.addEventListener('submit', handleFormSubmit);
    testCommandBtn.addEventListener('click', handleTestCommand);
  
    // 4. Real-time validation watchers (optional)
    addRealTimeValidation([
      directoryInput,
      providerSelect,
      modelSelect,
      caseStyleInput,
      charsInput,
      languageInput,
      includeSubdirectoriesInput,
      customPromptInput
    ]);
  
    // 5. Real-time validation for frames
    framesInput.addEventListener('input', () => validateFrames());
  
    // 6. Real-time validation for API Key if provider=OpenAI or Claude
    apiKeyInput.addEventListener('input', () => {
      if (providerIsOnline()) validateApiKey();
    });
  });
  
  /**
   * Called when form is submitted
   */
  function handleFormSubmit(e) {
    e.preventDefault();
    clearErrorSummary();
    clearAllFieldErrors();
  
    if (validateForm()) {
      // Save user prefs
      savePreferences();
      // Build & display the command
      const command = buildCommand();
      displayCommand(command);
    }
  }
  
  /**
   * Called when "Test Command" is clicked
   */
  function handleTestCommand() {
    clearErrorSummary();
    clearAllFieldErrors();
  
    if (validateForm()) {
      const cmd = buildCommand();
      console.log('[TEST COMMAND]', cmd);
      alert('Test Command logged in console.');
    }
  }
  
  /**
   * Populate model list, show/hide API key, show info box, etc.
   */
  function updateModels() {
    const provider = providerSelect.value;
    const modelSelect = document.getElementById('model');
  
    // Reset model list
    modelSelect.innerHTML = `<option value="" disabled selected>Select a model</option>`;
  
    // Info box logic
    providerInfo.style.display = 'none';
    providerInfo.textContent = '';
  
    if (!provider) {
      apiKeyGroup.style.display = 'none';
      return;
    }
  
    // Show/hide API Key as needed
    if (providerIsOnline()) {
      apiKeyGroup.style.display = 'block';
    } else {
      apiKeyGroup.style.display = 'none';
      document.getElementById('apiKey').value = '';
    }
  
    // Fill in model dropdown
    switch (provider) {
      case 'openai':
        addModelOption('gpt-4', true);
        addModelOption('gpt-3.5-turbo');
        providerInfo.style.display = 'block';
        providerInfo.innerHTML =
          'You have selected <strong>OpenAI</strong>. Remember you need an API key and a valid model name.';
        break;
  
      case 'claude':
        addModelOption('claude-instant', true);
        addModelOption('claude-v2');
        providerInfo.style.display = 'block';
        providerInfo.innerHTML =
          'You have selected <strong>Claude</strong>. An API key is required for Anthropicâ€™s Claude.';
        break;
  
      case 'ollama':
        addModelOption('llava:13b', true);
        addModelOption('gemma2');
        addModelOption('phi');
        providerInfo.style.display = 'block';
        providerInfo.innerHTML =
          'You have selected <strong>Ollama</strong>. Usually runs locally. Optionally set a custom <code>baseUrl</code> if not default.';
        break;
  
      case 'lm-studio':
        addModelOption('lmstudio-default', true);
        providerInfo.style.display = 'block';
        providerInfo.innerHTML =
          'You have selected <strong>LM Studio</strong>. Typically runs locally on <code>http://127.0.0.1:1234</code>.';
        break;
    }
  }
  
  /**
   * Helper to add a model <option> to #model.
   */
  function addModelOption(name, selected = false) {
    const opt = document.createElement('option');
    opt.value = name;
    opt.textContent = name;
    if (selected) opt.selected = true;
    modelSelect.appendChild(opt);
  }
  
  /**
   * Determines if the chosen provider is an external service requiring an API key
   */
  function providerIsOnline() {
    const providerVal = providerSelect.value;
    return providerVal === 'openai' || providerVal === 'claude';
  }
  
  /**
   * Validate the entire form
   */
  function validateForm() {
    let valid = true;
  
    // Required fields
    const requiredFields = [
      { el: directoryInput, name: 'Directory Path' },
      { el: providerSelect, name: 'Provider' },
      { el: modelSelect, name: 'Model' },
      { el: caseStyleInput, name: 'Case Style' },
      { el: charsInput, name: 'Character Limit' },
      { el: languageInput, name: 'Language' },
      { el: includeSubdirectoriesInput, name: 'Include Subdirectories' },
      { el: customPromptInput, name: 'Custom Prompt' }
    ];
  
    // Check for empty values
    requiredFields.forEach(field => {
      if (!field.el.value.trim()) {
        showFieldError(field.el, `${field.name} is required.`);
        valid = false;
      }
    });
  
    // Additional checks
    if (!validateDirectory()) valid = false;
    if (!validateFrames()) valid = false;
    if (providerIsOnline() && !validateApiKey()) valid = false;
  
    // If not valid, show summary
    if (!valid) {
      errorSummary.style.display = 'block';
      errorSummary.textContent =
        'Please correct the highlighted fields below and try again.';
    }
  
    return valid;
  }
  
  /**
   * Validate the "directory" input for a simple pattern (must start with "/").
   * Adjust for Windows or your environment.
   */
  function validateDirectory() {
    const value = directoryInput.value.trim();
    if (!value) return false;
    // Example: must start with "/"
    if (!value.startsWith('/')) {
      showFieldError(directoryInput, 'Directory path must begin with "/".');
      return false;
    }
    return true;
  }
  
  /**
   * Validate frames
   */
  function validateFrames() {
    const val = framesInput.value.trim();
    if (!val) return true; // optional
    const num = Number(val);
    if (!Number.isInteger(num) || num < 1 || num > 50) {
      showFieldError(framesInput, 'Frames must be an integer between 1 and 50.');
      return false;
    }
    return true;
  }
  
  /**
   * Validate API key if providerIsOnline
   */
  function validateApiKey() {
    const apiVal = apiKeyInput.value.trim();
    if (!apiVal) {
      showFieldError(apiKeyInput, 'API Key is required for the chosen provider.');
      return false;
    }
    return true;
  }
  
  /**
   * Real-time validation watchers
   */
  function addRealTimeValidation(fields) {
    fields.forEach(f => {
      f.addEventListener('input', () => {
        clearFieldError(f);
      });
    });
  }
  
  /**
   * Build final command
   */
  function buildCommand() {
    const directory = directoryInput.value.trim();
    const provider = providerSelect.value.trim();
    const model = modelSelect.value.trim();
    const baseUrl = baseUrlInput.value.trim();
    const frames = framesInput.value.trim();
    const caseStyle = caseStyleInput.value.trim();
    const chars = charsInput.value.trim();
    const language = languageInput.value.trim();
    const includeSubs = includeSubdirectoriesInput.value.trim();
    const customPrompt = customPromptInput.value.trim();
    const apiKey = apiKeyInput.value.trim();
  
    let cmd = `ai-renamer "${directory}" \\\n  --provider=${provider} \\\n  --model=${model}`;
  
    // If provider requires API key
    if (providerIsOnline()) {
      cmd += ` \\\n  --api-key="${escapeForCommand(apiKey)}"`;
    }
  
    if (baseUrl) {
      cmd += ` \\\n  --base-url="${escapeForCommand(baseUrl)}"`;
    }
  
    if (frames) {
      cmd += ` \\\n  --frames=${frames}`;
    }
  
    if (caseStyle) {
      cmd += ` \\\n  --case=${caseStyle}`;
    }
  
    if (chars) {
      cmd += ` \\\n  --chars=${chars}`;
    }
  
    if (language) {
      cmd += ` \\\n  --language="${escapeForCommand(language)}"`;
    }
  
    if (includeSubs) {
      cmd += ` \\\n  --include-subdirectories=${includeSubs}`;
    }
  
    if (customPrompt) {
      cmd += ` \\\n  --custom-prompt="${escapeForCommand(customPrompt)}"`;
    }
  
    return cmd;
  }
  
  /**
   * Display the generated command
   */
  function displayCommand(cmd) {
    const wrapper = document.getElementById('generatedCommandWrapper');
    const cmdText = document.getElementById('commandText');
  
    cmdText.textContent = cmd;
    wrapper.style.display = 'block';
  }
  
  /**
   * Hide the command section
   */
  function hideCommand() {
    const wrapper = document.getElementById('generatedCommandWrapper');
    wrapper.style.display = 'none';
  }
  
  /**
   * Copy command to clipboard
   */
  function copyCommand() {
    const cmdText = document.getElementById('commandText').textContent;
    navigator.clipboard.writeText(cmdText)
      .then(() => {
        alert('Command copied to clipboard!');
      })
      .catch(err => {
        console.error('Clipboard copy failed:', err);
        alert('Failed to copy. Please copy manually.');
      });
  }
  
  /**
   * Escape special characters for shell usage
   */
  function escapeForCommand(str) {
    return str.replace(/(["\\$`])/g, '\\$1');
  }
  
  /**
   * Save preferences to localStorage
   */
  function savePreferences() {
    const prefs = {
      provider: providerSelect.value.trim(),
      model: modelSelect.value.trim(),
      caseStyle: caseStyleInput.value.trim(),
      language: languageInput.value.trim(),
      customPrompt: customPromptInput.value.trim()
    };
    localStorage.setItem('aiRenamerPrefs', JSON.stringify(prefs));
  }
  
  /**
   * Load preferences from localStorage
   */
  function loadPreferences() {
    const raw = localStorage.getItem('aiRenamerPrefs');
    if (!raw) return;
    try {
      const { provider, model, caseStyle, language, customPrompt } = JSON.parse(raw);
      if (provider) providerSelect.value = provider;
      if (caseStyle) caseStyleInput.value = caseStyle;
      if (language) languageInput.value = language;
      if (customPrompt) customPromptInput.value = customPrompt;
  
      // We'll attempt to set model in updateModels() with a slight delay
      setTimeout(() => {
        if (model) modelSelect.value = model;
      }, 300);
    } catch (err) {
      console.warn('Failed to parse prefs:', err);
    }
  }
  
  /**
   * Show an error message for a specific field
   */
  function showFieldError(el, msg) {
    const id = el.id + 'Error';
    const errorEl = document.getElementById(id);
    if (errorEl) {
      errorEl.textContent = msg;
      errorEl.style.display = 'block';
    }
    el.classList.add('invalid-field');
  }
  
  /**
   * Clear error for a specific field
   */
  function clearFieldError(el) {
    const id = el.id + 'Error';
    const errorEl = document.getElementById(id);
    if (errorEl) {
      errorEl.textContent = '';
      errorEl.style.display = 'none';
    }
    el.classList.remove('invalid-field');
  }
  
  /**
   * Clear all field errors
   */
  function clearAllFieldErrors() {
    const allErrors = document.querySelectorAll('.error-message');
    allErrors.forEach(err => {
      err.textContent = '';
      err.style.display = 'none';
    });
  
    const invalidEls = document.querySelectorAll('.invalid-field');
    invalidEls.forEach(el => el.classList.remove('invalid-field'));
  }
  
  /**
   * Clear the top-level error summary
   */
  function clearErrorSummary() {
    errorSummary.style.display = 'none';
    errorSummary.textContent = '';
  }
  